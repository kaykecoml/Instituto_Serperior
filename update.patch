diff --git a/js/pokemon-view.js b/js/pokemon-view.js
index 45b4414e08273e59c3d88d264d97917f4f7cf831..130cdd0bcf92c469d4be7e0a15bf01166d58f33e 100644
--- a/js/pokemon-view.js
+++ b/js/pokemon-view.js
@@ -347,50 +347,51 @@ function updateSearchPreview() {
   card.appendChild(img);
   card.appendChild(name);
 
   card.onclick = () => {
     preview.innerHTML = "";
     nameInput.value = "";
     dexInput.value = "";
 
     loadPokemonById(found.id); // ðŸ”¥ AQUI Ã© o segredo
   };
 
   preview.appendChild(card);
 }
 
 async function getMoveDetails(url) {
   if (moveCache.has(url)) {
     return moveCache.get(url);
   }
 
   const data = await fetch(url).then((r) => r.json());
   moveCache.set(url, data);
   return data;
 }
 
 const bulbapediaCache = {};
+const speciesDexCache = {};
 
 async function fetchJsonWithRetry(url, retries = 2) {
   let lastError = null;
 
   for (let attempt = 0; attempt <= retries; attempt++) {
     try {
       const response = await fetch(url);
 
       if (!response.ok) {
         throw new Error(`HTTP ${response.status}`);
       }
 
       return await response.json();
     } catch (error) {
       lastError = error;
 
       if (attempt < retries) {
         await new Promise((resolve) => setTimeout(resolve, 350 * (attempt + 1)));
       }
     }
   }
 
   throw lastError;
 }
 
@@ -409,107 +410,179 @@ function getBulbapediaPageCandidates(pokemonName) {
 }
 
 async function fetchBulbapediaBiology(pokemonName) {
   if (bulbapediaCache[pokemonName]) {
     return bulbapediaCache[pokemonName];
   }
 
   try {
     const pageCandidates = getBulbapediaPageCandidates(pokemonName);
     let pageName = null;
     let sections = null;
 
     for (const candidate of pageCandidates) {
       const sectionsData = await fetchJsonWithRetry(
         `https://bulbapedia.bulbagarden.net/w/api.php?action=parse&page=${encodeURIComponent(candidate)}_(Pok%C3%A9mon)&prop=sections&format=json&origin=*`,
       );
 
       if (sectionsData.parse?.sections?.length) {
         pageName = `${candidate}_(Pok%C3%A9mon)`;
         sections = sectionsData.parse.sections;
         break;
       }
     }
 
     if (!sections || !pageName) {
-      return "Biologia nÃ£o encontrada.";
+      return null;
     }
     const biologySection = sections.find((s) => {
       const normalizedLine = s.line.toLowerCase();
       return (
         normalizedLine.includes("biology") || normalizedLine.includes("biologia")
       );
     });
 
     if (!biologySection) {
-      return "Biologia nÃ£o encontrada.";
+      return null;
     }
 
     const sectionData = await fetchJsonWithRetry(
       `https://bulbapedia.bulbagarden.net/w/api.php?action=parse&page=${encodeURIComponent(pageName)}&prop=text&section=${biologySection.index}&format=json&origin=*`,
     );
 
     if (!sectionData.parse?.text) {
-      return "DescriÃ§Ã£o nÃ£o encontrada.";
+      return null;
     }
 
     const html = sectionData.parse.text["*"];
 
     const tempDiv = document.createElement("div");
     tempDiv.innerHTML = html;
 
     /* REMOVE LIXO VISUAL */
     tempDiv
       .querySelectorAll("table, sup, .reference, .thumb, .gallery")
       .forEach((e) => e.remove());
 
     /* PEGAR TODOS OS PARÃGRAFOS REAIS */
     const paragraphs = [...tempDiv.querySelectorAll("p")]
       .map((p) => p.textContent.trim())
       .filter(
         (t) =>
           t.length > 80 && // evita lixo pequeno
           !t.toLowerCase().includes("this pokÃ©mon"), // evita frases repetitivas pequenas
       );
 
     if (paragraphs.length === 0) {
-      return "DescriÃ§Ã£o nÃ£o encontrada.";
+      return null;
     }
 
     let finalText = paragraphs.join("\n\n");
 
     finalText = await translateToPortuguese(finalText);
 
     bulbapediaCache[pokemonName] = finalText;
 
     return finalText;
   } catch (err) {
     console.error("Erro Bulbapedia:", err);
-    return "Erro ao carregar biologia.";
+    return null;
   }
 }
 
+function normalizeDexText(text) {
+  return text
+    .replace(/[\n\f\r]+/g, " ")
+    .replace(/\s+/g, " ")
+    .trim();
+}
+
+function getPreferredFlavorEntry(entries, language) {
+  const byLanguage = entries.filter((entry) => entry.language.name === language);
+
+  if (byLanguage.length === 0) {
+    return null;
+  }
+
+  const versionOrder = [
+    "scarlet",
+    "violet",
+    "sword",
+    "shield",
+    "sun",
+    "moon",
+    "ultra-sun",
+    "ultra-moon",
+  ];
+
+  for (const version of versionOrder) {
+    const match = byLanguage.find((entry) => entry.version.name === version);
+    if (match) return match;
+  }
+
+  return byLanguage[byLanguage.length - 1];
+}
+
+async function getDexEntryFromSpecies(species) {
+  const cacheKey = species.id || species.name;
+
+  if (speciesDexCache[cacheKey]) {
+    return speciesDexCache[cacheKey];
+  }
+
+  const ptEntry = getPreferredFlavorEntry(species.flavor_text_entries, "pt-BR");
+  if (ptEntry?.flavor_text) {
+    const text = normalizeDexText(ptEntry.flavor_text);
+    speciesDexCache[cacheKey] = text;
+    return text;
+  }
+
+  const enEntry = getPreferredFlavorEntry(species.flavor_text_entries, "en");
+  if (!enEntry?.flavor_text) {
+    return null;
+  }
+
+  const translated = await translateToPortuguese(normalizeDexText(enEntry.flavor_text));
+  speciesDexCache[cacheKey] = translated;
+
+  return translated;
+}
+
+async function getDexEntryText(pokemon, species) {
+  const bulbapediaText = await fetchBulbapediaBiology(pokemon.name);
+  if (bulbapediaText) {
+    return bulbapediaText;
+  }
+
+  const speciesText = await getDexEntryFromSpecies(species);
+  if (speciesText) {
+    return speciesText;
+  }
+
+  return "DescriÃ§Ã£o da dex nÃ£o encontrada.";
+}
+
 async function loadPokemonById(idOrName) {
   currentId = idOrName;
 
   const pokeRes = await fetch(`https://pokeapi.co/api/v2/pokemon/${idOrName}`);
   const pokemon = await pokeRes.json();
 
   loadPokemon(pokemon);
 
   history.pushState(null, "", `?id=${pokemon.id}`);
 }
 
 function renderForms(varieties, baseName) {
   const container = document.getElementById("form-buttons");
   container.innerHTML = "";
 
   // BOTÃƒO BASE (apenas 1 vez)
   const baseBtn = document.createElement("button");
   baseBtn.textContent = "Base";
   baseBtn.className = "form-base-btn";
   baseBtn.onclick = () => applyPokemonData(basePokemon);
   container.appendChild(baseBtn);
 
   varieties.forEach((v) => {
     const name = v.pokemon.name;
 
@@ -539,63 +612,62 @@ function renderForms(varieties, baseName) {
     }
 
     // FORMAS REGIONAIS / OUTRAS
     const btn = document.createElement("button");
     btn.textContent = name.replace(baseName + "-", "");
     btn.className = "tab-btn";
     btn.onclick = () => loadForm(name);
     container.appendChild(btn);
   });
 }
 
 function loadForm(name) {
   fetch(`https://pokeapi.co/api/v2/pokemon/${name}`)
     .then((res) => res.json())
     .then((pokemon) => {
       if (!pokemon.moves || pokemon.moves.length === 0) {
         pokemon.moves = basePokemon?.moves || [];
       }
       applyPokemonData(pokemon);
     });
 }
 
 async function applyPokemonData(p) {
   const dexEntry = document.getElementById("dex-entry");
 
-  dexEntry.textContent = "Carregando biologia...";
-
-  const biologyText = await fetchBulbapediaBiology(p.name);
-
-  dexEntry.classList.remove("expanded");
-  dexEntry.textContent = biologyText;
+  dexEntry.textContent = "Carregando entrada da dex...";
 
   document.getElementById("dexContent").classList.remove("open");
   const dexToggleButton = document.getElementById("dexToggleBtn");
   dexToggleButton.classList.remove("active");
   dexToggleButton.textContent = "â–¸ ENTRADA DA DEX";
 
   const species = await fetch(p.species.url).then((res) => res.json());
+  const dexText = await getDexEntryText(p, species);
+
+  dexEntry.classList.remove("expanded");
+  dexEntry.textContent = dexText;
 
   const pokemonData = buildPokemonData(p, species);
 
   const chainData = await fetch(species.evolution_chain.url).then((r) =>
     r.json(),
   );
 
   function findNode(name, node) {
     if (node.species.name === name) return node;
 
     for (const next of node.evolves_to) {
       const found = findNode(name, next);
       if (found) return found;
     }
     return null;
   }
 
   let node = findNode(p.name, chainData.chain);
 
   if (!node && p.name.includes("-")) {
     const baseName = p.name.split("-")[0];
     node = findNode(baseName, chainData.chain);
   }
 
   if (!node) {
