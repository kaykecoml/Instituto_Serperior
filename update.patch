diff --git a/js/pokemon-view.js b/js/pokemon-view.js
index 67152040cb8adabd70ae124f6b69e653ce69b1ac..5984936ed2a1c200460f38dfd3e2353de6a14464 100644
--- a/js/pokemon-view.js
+++ b/js/pokemon-view.js
@@ -1,43 +1,46 @@
 import { HABITATS } from "./habitats.js";
 import { powerToDamage, accuracyToRPG, ppToRPG } from "./utils.js";
 import { abilitiesData } from "./abilities.js";
 const moveCache = new Map();
 const pokemonSpriteCache = new Map();
 const itemSpriteCache = new Map();
 const speciesVarietyCache = new Map();
 const pokemonDataCache = new Map();
 const evolutionChainCache = new Map();
 let statsChart = null;
 let contestChart = null;
 let damageToken = 0;
 let currentPokemonData = null;
 let currentMovesData = null;
 const translationCache = {};
 const BULBAPEDIA_API_URL = "https://bulbapedia.bulbagarden.net/w/api.php";
 const BULBAPEDIA_PAGE_SUFFIX = "(Pokémon)";
 const BULBAPEDIA_STORAGE_PREFIX = "bulbapedia-biology-pt:";
+const BULBAPEDIA_FAILURE_PREFIX = "bulbapedia-biology-fail:";
+const BULBAPEDIA_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 7; // 7 dias
+const BULBAPEDIA_FAILURE_COOLDOWN_MS = 1000 * 60 * 60 * 6; // 6 horas
 
 const RPG_VERSION_PRIORITY = [
   "scarlet-violet",
   "sword-shield",
   "ultra-sun-ultra-moon",
   "sun-moon",
   "omega-ruby-alpha-sapphire",
   "x-y",
   "black-2-white-2",
   "black-white",
 ];
 
 const EXCLUDED_VERSION_GROUPS = ["legends-za"];
 
 const INT_LABELS = [
   "Instintivo",
   "Consciente",
   "Racional",
   "Estrategista",
   "Gênio",
 ];
 const STR_LABELS = [
   "Frágil",
   "Subdesenvolvida",
   "Robusta",
@@ -444,225 +447,318 @@ function updateSearchPreview() {
     };
 
     list.appendChild(card);
   });
 
   preview.appendChild(list);
 }
 
 async function getMoveDetails(url) {
   if (moveCache.has(url)) {
     return moveCache.get(url);
   }
 
   const data = await fetch(url).then((r) => r.json());
   moveCache.set(url, data);
   return data;
 }
 
 const bulbapediaCache = {};
 function getBulbapediaStorageKey(pokemonName) {
   return `${BULBAPEDIA_STORAGE_PREFIX}${pokemonName.toLowerCase()}`;
 }
 
 function getBulbapediaFromStorage(pokemonName) {
   try {
-    return localStorage.getItem(getBulbapediaStorageKey(pokemonName));
+    const raw = localStorage.getItem(getBulbapediaStorageKey(pokemonName));
+    if (!raw) return null;
+
+    try {
+      const parsed = JSON.parse(raw);
+      if (!parsed || typeof parsed !== "object") return raw;
+
+      if (!parsed.text || !parsed.savedAt) return null;
+      if (Date.now() - parsed.savedAt > BULBAPEDIA_CACHE_TTL_MS) return null;
+
+      return parsed.text;
+    } catch {
+      // compatibilidade com formato antigo (texto cru)
+      return raw;
+    }
   } catch {
     return null;
   }
 }
 
 function saveBulbapediaToStorage(pokemonName, text) {
   try {
-    localStorage.setItem(getBulbapediaStorageKey(pokemonName), text);
+    localStorage.setItem(
+      getBulbapediaStorageKey(pokemonName),
+      JSON.stringify({ text, savedAt: Date.now() }),
+    );
+    localStorage.removeItem(`${BULBAPEDIA_FAILURE_PREFIX}${pokemonName.toLowerCase()}`);
   } catch {
     // Ignora falhas de quota/storage privado.
   }
 }
 
+function markBulbapediaFetchFailure(pokemonName) {
+  try {
+    localStorage.setItem(
+      `${BULBAPEDIA_FAILURE_PREFIX}${pokemonName.toLowerCase()}`,
+      String(Date.now() + BULBAPEDIA_FAILURE_COOLDOWN_MS),
+    );
+  } catch {
+    // sem storage disponível
+  }
+}
+
+function shouldSkipBulbapediaFetch(pokemonName) {
+  try {
+    const nextRetryAt = Number(
+      localStorage.getItem(`${BULBAPEDIA_FAILURE_PREFIX}${pokemonName.toLowerCase()}`),
+    );
+    return Number.isFinite(nextRetryAt) && nextRetryAt > Date.now();
+  } catch {
+    return false;
+  }
+}
+
 async function fetchJsonWithRetry(url, retries = 2) {
   let lastError = null;
 
   for (let attempt = 0; attempt <= retries; attempt++) {
     try {
       const response = await fetch(url);
 
       if (!response.ok) {
         throw new Error(`HTTP ${response.status}`);
       }
 
       return await response.json();
     } catch (error) {
       lastError = error;
 
       if (attempt < retries) {
         await new Promise((resolve) => setTimeout(resolve, 350 * (attempt + 1)));
       }
     }
   }
 
   throw lastError;
 }
 
 async function callBulbapediaApi(params) {
   const url = new URL(BULBAPEDIA_API_URL);
   Object.entries({ format: "json", origin: "*", ...params }).forEach(
     ([key, value]) => {
       if (value !== undefined && value !== null && value !== "") {
         url.searchParams.set(key, String(value));
       }
     },
   );
 
   return fetchJsonWithRetry(url.toString());
 }
 
+async function callBulbapediaApiWithProxyFallback(params) {
+  try {
+    return await callBulbapediaApi(params);
+  } catch (error) {
+    const message = String(error?.message || "");
+    const shouldUseProxy = message.includes("HTTP 403") || message.includes("HTTP 429");
+
+    if (!shouldUseProxy) throw error;
+
+    const url = new URL(BULBAPEDIA_API_URL);
+    Object.entries({ format: "json", origin: "*", ...params }).forEach(
+      ([key, value]) => {
+        if (value !== undefined && value !== null && value !== "") {
+          url.searchParams.set(key, String(value));
+        }
+      },
+    );
+
+    const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url.toString())}`;
+    return fetchJsonWithRetry(proxyUrl, 1);
+  }
+}
+
 function getBulbapediaPageCandidates(pokemonName) {
   const cleanedName = pokemonName.trim().toLowerCase();
   const baseName = cleanedName.split("-")[0];
 
   const candidates = [cleanedName, baseName]
     .filter(Boolean)
     .map((name) =>
       name
         .split("-")
         .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
         .join("_"),
     )
     .map((name) => `${name}_${BULBAPEDIA_PAGE_SUFFIX}`);
 
   return [...new Set(candidates)];
 }
 
 function extractParagraphsFromBiologyHtml(html) {
   const tempDiv = document.createElement("div");
   tempDiv.innerHTML = html;
 
   tempDiv
     .querySelectorAll(
       "table, sup, .reference, .thumb, .gallery, .navbox, .metadata, .mw-editsection, .hatnote, script, style",
     )
     .forEach((e) => e.remove());
 
   const parserRoot = tempDiv.querySelector(".mw-parser-output") || tempDiv;
   const paragraphs = [];
 
+  const normalizeText = (rawText) =>
+    rawText
+      .replace(/\[[^\]]+\]/g, " ")
+      .replace(/\s+/g, " ")
+      .trim();
+
+  const addTextIfUseful = (rawText) => {
+    const text = normalizeText(rawText);
+    if (text.length >= 40 && !paragraphs.includes(text)) {
+      paragraphs.push(text);
+    }
+  };
+
   for (const element of parserRoot.children) {
     const tag = element.tagName?.toLowerCase();
     if (!tag) continue;
 
     if (["h2", "h3", "h4", "h5", "h6"].includes(tag)) {
       break;
     }
 
-    if (tag !== "p") continue;
+    if (tag === "p") {
+      addTextIfUseful(element.textContent || "");
+      continue;
+    }
 
-    const text = element.textContent
-      .replace(/\[[^\]]+\]/g, " ")
-      .replace(/\s+/g, " ")
-      .trim();
+    if (tag === "ul" || tag === "ol") {
+      element.querySelectorAll("li").forEach((li) => {
+        addTextIfUseful(li.textContent || "");
+      });
+      continue;
+    }
 
-    if (text.length >= 40) {
-      paragraphs.push(text);
+    if (tag === "div") {
+      const inlineParagraphs = element.querySelectorAll("p");
+      if (inlineParagraphs.length > 0) {
+        inlineParagraphs.forEach((p) => addTextIfUseful(p.textContent || ""));
+      } else {
+        addTextIfUseful(element.textContent || "");
+      }
     }
   }
 
   return paragraphs;
 }
 
 async function fetchBiologySectionHtml(pageTitle, biologySectionIndex) {
-  const sectionData = await callBulbapediaApi({
+  const sectionData = await callBulbapediaApiWithProxyFallback({
     action: "parse",
     page: pageTitle,
     prop: "text",
     section: biologySectionIndex,
   });
 
   return sectionData.parse?.text?.["*"] || null;
 }
 
 async function fetchBulbapediaBiology(pokemonName) {
+  if (shouldSkipBulbapediaFetch(pokemonName)) {
+    return null;
+  }
+
   if (bulbapediaCache[pokemonName]) {
     return bulbapediaCache[pokemonName];
   }
 
   const stored = getBulbapediaFromStorage(pokemonName);
   if (stored) {
     bulbapediaCache[pokemonName] = stored;
     return stored;
   }
 
   try {
     const pageCandidates = getBulbapediaPageCandidates(pokemonName);
     let pageName = "";
     let biologySectionIndex = "";
 
     for (const candidate of pageCandidates) {
-      const sectionsData = await callBulbapediaApi({
+      const sectionsData = await callBulbapediaApiWithProxyFallback({
         action: "parse",
         page: candidate,
         prop: "sections",
       });
 
       const sections = sectionsData.parse?.sections || [];
       const biologySection = sections.find((s) => {
         const normalizedLine = s.line?.toLowerCase?.() || "";
         return (
           normalizedLine.includes("biology") || normalizedLine.includes("biologia")
         );
       });
 
       if (biologySection?.index) {
         pageName = sectionsData.parse?.title || candidate;
         biologySectionIndex = biologySection.index;
         break;
       }
     }
 
     if (!pageName || !biologySectionIndex) {
+      markBulbapediaFetchFailure(pokemonName);
       return null;
     }
 
     const html = await fetchBiologySectionHtml(pageName, biologySectionIndex);
     if (!html) return null;
 
     const paragraphs = extractParagraphsFromBiologyHtml(html);
 
     if (paragraphs.length === 0) {
+      markBulbapediaFetchFailure(pokemonName);
       return null;
     }
 
     let finalText = paragraphs.join("\n\n");
 
     finalText = await translateToPortuguese(finalText);
 
     bulbapediaCache[pokemonName] = finalText;
     saveBulbapediaToStorage(pokemonName, finalText);
 
     return finalText;
   } catch (err) {
+    markBulbapediaFetchFailure(pokemonName);
     console.error("Erro Bulbapedia:", err);
     return null;
   }
 }
 
 async function getDexEntryText(pokemon) {
   const bulbapediaText = await fetchBulbapediaBiology(pokemon.name);
   if (bulbapediaText) {
     return bulbapediaText;
   }
 
   return "Descrição da Bulbapedia indisponível no momento.";
 }
 
 async function loadPokemonById(idOrName) {
   if (isPokemonLoading) return;
 
   isPokemonLoading = true;
 
   try {
     const pokemon = await getPokemonData(idOrName);
 
     loadPokemon(pokemon);
     window.scrollTo({ top: 0, behavior: "smooth" });
 
